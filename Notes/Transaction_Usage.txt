TRANSACTIONS IN THIS PROJECT
============================

1) Definition (simple)
----------------------
A **transaction** is a group of database operations that are treated as a single unit of work.
- Either **all** operations succeed, or **none** are applied.
- In MongoDB with Mongoose, transactions are handled using a **session** and `withTransaction()`.
- This gives you ACID properties:
  - **Atomicity**: all-or-nothing
  - **Consistency**: data rules are preserved
  - **Isolation**: concurrent operations don't corrupt each other
  - **Durability**: once committed, changes survive crashes

In your project, transactions are used where data must stay **consistent across multiple collections or multiple steps** (orders + stock + notifications).


2) Where transactions are used (files + code)
--------------------------------------------

A) `Backend/Controller/order_controller.js`
   Function: `createOrder`

   Purpose: Create an order **and** update product stock **and** send notifications as a single atomic operation.

   Key code (simplified):

   ```js
   import mongoose from "mongoose";
   import Order from "../models/order.model.js";
   import Product from "../models/product.model.js";

   export const createOrder = async (req, res) => {
     const orderData = req.body;

     // Start a MongoDB session for transaction
     const session = await mongoose.startSession();

     try {
       // Start transaction (ACID)
       await session.withTransaction(async () => {
         // 1) Validate and reserve stock for all items
         for (const item of orderData.items) {
           const product = await Product.findById(item.productId).session(session);

           if (!product) {
             throw new Error(`Product ${item.productId} not found`);
           }

           if (product.quantity < item.quantity) {
             throw new Error(
               `Insufficient stock for ${product.name}. Available: ${product.quantity}, Requested: ${item.quantity}`
             );
           }

           // Decrement stock atomically
           const updateResult = await Product.updateOne(
             {
               _id: item.productId,
               quantity: { $gte: item.quantity } // Ensure stock hasn't changed
             },
             {
               $inc: { quantity: -item.quantity }
             },
             { session }
           );

           if (updateResult.modifiedCount === 0) {
             throw new Error(`Failed to reserve stock for ${product.name}. Please try again.`);
           }

           // Optional: low stock / out-of-stock notifications here
         }

         // 2) Create the order inside the same transaction
         const [newOrder] = await Order.create([orderData], { session });

         // 3) Create notifications for user/admins (still inside transaction)
         //    using createNotificationHelper(..., { session }) pattern
       });

       // If we reach here, transaction committed successfully
       // Transaction guarantee: either ALL steps above work, or NONE are applied

     } catch (error) {
       // Transaction is rolled back automatically on error
     } finally {
       session.endSession();
     }
   };
   ```

   Transaction concepts here:
   - **Atomicity**: stock updates + order creation + notifications are one logical unit.
   - **Consistency**: you can never have an order created without stock being decremented.
   - **Isolation**: two customers ordering at the same time won't corrupt stock because of the `{ quantity: { $gte: ... } }` check inside a transaction.


B) `Backend/Controller/product_controller.js`
   Function: `updateProduct`

   Purpose: When updating a product, if the `quantity` field is changed, use a transaction so that:
   - The product quantity
   - The low-stock / out-of-stock notifications to admins
   are kept in sync.

   Key code (simplified):

   ```js
   import productModel from "../models/product.model.js";
   import User from "../models/user.model.js";
   import mongoose from "mongoose";
   import { createNotificationHelper } from "./notification_controller.js";

   export const updateProduct = async (req, res) => {
     const { id: userProductId } = req.params;
     const userProduct = req.body;

     // Start session for transaction if updating quantity
     const session = userProduct.quantity !== undefined
       ? await mongoose.startSession()
       : null;

     try {
       let updatedProduct;

       if (session) {
         // Use transaction for stock updates
         await session.withTransaction(async () => {
           updatedProduct = await productModel.findByIdAndUpdate(
             userProductId,
             userProduct,
             { new: true, runValidators: true, session }
           );

           if (!updatedProduct) {
             throw new Error("Product not found");
           }

           const LOW_STOCK_THRESHOLD = 10;

           // Low stock notification
           if (updatedProduct.quantity <= LOW_STOCK_THRESHOLD && updatedProduct.quantity > 0) {
             const admins = await User.find({ role: 'admin' }).session(session);
             for (const admin of admins) {
               await createNotificationHelper(
                 admin._id,
                 'product',
                 '‚ö†Ô∏è Low Stock Alert',
                 `Product "${updatedProduct.name}" has only ${updatedProduct.quantity} items left in stock!`,
                 `/admin/products/${updatedProduct._id}`,
                 'alert-triangle',
                 'high'
               );
             }
           }

           // Out of stock notification
           if (updatedProduct.quantity === 0) {
             const admins = await User.find({ role: 'admin' }).session(session);
             for (const admin of admins) {
               await createNotificationHelper(
                 admin._id,
                 'product',
                 'üö® Out of Stock',
                 `Product "${updatedProduct.name}" is now out of stock!`,
                 `/admin/products/${updatedProduct._id}`,
                 'x-circle',
                 'high'
               );
             }
           }
         });
       } else {
         // Simple update without transaction
         updatedProduct = await productModel.findByIdAndUpdate(
           userProductId,
           userProduct,
           { new: true, runValidators: true }
         );
       }

       // After transaction: broadcast product update via websockets
     } finally {
       if (session) {
         session.endSession();
       }
     }
   };
   ```

   Transaction concepts here:
   - **Atomicity**: quantity update + admin notifications happen together.
   - **Consistency**: you never send "low stock" notifications for a product whose quantity update failed.


3) What would happen WITHOUT transactions?
-----------------------------------------

Examples of possible problems if we removed transactions:

- In `createOrder`:
  - Stock might be decremented but order fails to save ‚Üí inventory goes down but no order exists.
  - Order might save but stock update fails ‚Üí you oversell products, possibly going into negative inventory.
  - Notifications might be sent for orders that never really existed.

- In `updateProduct` when changing quantity:
  - Quantity could change but notifications fail ‚Üí admins never see low/out-of-stock alerts.
  - Notifications could be created but the quantity change fails ‚Üí dashboard shows wrong information.

Transactions in your project are mainly used to keep **orders + inventory + notifications** in sync and safe under concurrency.
